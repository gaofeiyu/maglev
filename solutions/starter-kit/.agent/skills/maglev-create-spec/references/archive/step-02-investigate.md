---
name: 'step-02-investigate'
description: '映射代码库中的技术约束和锚点'

workflow_path: '{project-root}/_bmad/bmm/workflows/bmad-quick-flow/create-tech-spec'
nextStepFile: './step-03-generate.md'
wipFile: '{implementation_artifacts}/tech-spec-wip.md'
---

# 步骤 2: 映射技术约束和锚点

**进度：第 2 步，共 4 步** - 下一步：生成计划

## 规则:

- 必须不 跳过步骤。
- 必须不 优化顺序。
- 必须 遵循确切说明。
- 必须不 尚未生成完整规范（那是步骤 3）。
- ✅ 你必须始终使用配置的 `{communication_language}` 以你的 Agent 沟通风格输出语言

## 上下文:

- 需要来自第 1 步的带有“问题陈述”的 `{wipFile}`。
- 重点：将问题陈述映射到代码库中的特定锚点。
- 输出：要触摸的确切文件，要扩展的类/模式，以及识别的技术约束。
- 目标：为计划提供实施就绪的地面真值。

## 指令序列

### 1. 加载当前状态

**读取 `{wipFile}` 并提取：**

- 概述部分的问题陈述和范围
- 第 1 步收集的任何上下文

### 2. 执行调查路径

**通用代码调查：**

_在可用时隔离子代理/任务中的深度探索。仅返回提取的摘要以防止上下文滚雪球。_

a) **建立在第 1 步的快速扫描基础上**

回顾第 1 步的定向扫描中发现的内容。然后问：

"根据我的快速浏览，我看到了 [发现的文件/模式]。我是否应该深入调查其他文件或目录？"

b) **阅读和分析代码**

对于提供的每个文件/目录：

- 阅读完整的文件
- 识别模式、惯例、编码风格
- 注意依赖项和导入
- 查找相关测试文件

**如果未发现相关代码（全新开始）：**

- 识别功能应所在的目​​标目录。
- 扫描父目录以获取架构上下文。
- 识别应使用的标准项目实用程序或样板。
- 将此记录为“确认全新开始” - 确定不存在遗留约束。

c) **记录技术上下文**

捕获并与用户确认：

- **技术栈**：语言、框架、库
- **代码模式**：架构模式、命名约定、文件结构
- **要修改/创建的文件**：需要更改的特定文件或要创建的新文件
- **测试模式**：测试的结构、使用的测试框架

d) **查找 project-context.md**

如果 `**/project-context.md` 存在且未在第 1 步中加载：

- 现在加载它
- 提取模式和惯例
- 注意任何必须遵循的规则

### 3. 更新 WIP 文件

**更新 `{wipFile}` frontmatter：**

```yaml
---
# ... existing frontmatter ...
stepsCompleted: [1, 2]
tech_stack: ['{captured_tech_stack}']
files_to_modify: ['{captured_files}']
code_patterns: ['{captured_patterns}']
test_patterns: ['{captured_test_patterns}']
---
```

**更新开发上下文部分：**

填写：

- 代码库模式（来自调查）
- 参考文件表（审查的文件）
- 技术决策（调查期间做出的任何决定）

**向用户报告：**

"**上下文已收集：**

- 技术栈: {tech_stack_summary}
- 要修改的文件: 识别出 {files_count} 个文件
- 模式: {patterns_summary}
- 测试: {test_patterns_summary}"

### 4. 展示检查点菜单

显示： "**选择：** [A] 高级诱导 [P] 派对模式 [C] 继续生成规范 (第 3 步，共 4 步)"

**停止并等待用户选择。**

#### 菜单处理逻辑：

- 如果 A: 完整阅读并遵循：`{advanced_elicitation}` 使用当前 tech-spec 内容，处理增强见解，询问用户 "接受改进？(y/n)"，如果是更新 WIP 文件然后重新显示菜单，如果否保持原始然后重新显示菜单
- 如果 P: 完整阅读并遵循：`{party_mode_exec}` 使用当前 tech-spec 内容，处理协作见解，询问用户 "接受更改？(y/n)"，如果是更新 WIP 文件然后重新显示菜单，如果否保持原始然后重新显示菜单
- 如果 C: 验证 frontmatter 更新为 `stepsCompleted: [1, 2]`，然后完整阅读并遵循：`{nextStepFile}`
- 如果 其他评论或查询：有帮助地回应然后重新显示菜单

#### 执行规则：

- 始终 在展示菜单后停止并等待用户输入
- 仅 当用户选择 'C' 时才进行下一步
- 在 A 或 P 执行后，返回此菜单

---

## 必需输出：

- 必须 记录技术上下文（堆栈、模式、识别的文件）。
- 必须 使用功能上下文更新 `{wipFile}`。

## 验证清单：

- [ ] 执行并记录技术映射。
- [ ] 在 frontmatter 中设置 `stepsCompleted: [1, 2]`。
